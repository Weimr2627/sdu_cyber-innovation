# 基于DDH的私有交集求和协议详解

## 1. 算法概述

基于判定性Diffie-Hellman（DDH）假设的私有交集求和协议是一种安全的多方计算方案，允许两个参与方在不泄露各自私有数据的前提下，计算双方数据交集对应值的总和。

### 核心问题解决
- 参与方1拥有标识符集合（如用户ID）
- 参与方2拥有(标识符, 数值)键值对（如用户ID及其消费金额）
- 双方希望计算共同标识符（交集）所对应数值的总和
- 过程中不泄露任何非交集元素的信息

### 安全性基础
协议安全性基于**DDH假设**：在计算上无法有效区分以下两种三元组：
- 真实三元组：(g^a, g^b, g^(ab))，其中a、b为随机数
- 随机三元组：(g^a, g^b, g^c)，其中a、b、c为随机数

这一特性确保了双方可以验证元素是否在交集中，同时不泄露原始数据。

## 2. 核心功能

| 功能 | 说明 |
|------|------|
| 隐私保护的交集计算 | 仅泄露交集元素的存在性，不泄露任何非交集元素 |
| 私有求和 | 仅泄露交集元素对应值的总和，不泄露单个元素的具体值 |
| 数据机密性 | 原始数据始终保存在本地，仅传输经过加密变换的数据 |
| 计算高效性 | 基于模运算和哈希函数，时间复杂度为O(n)（n为数据规模） |

## 3. 算法伪代码

### 3.1 协议初始化
```plaintext
函数 初始化协议(p, g):
    if p 未指定:
        p = 2147483647  // 大质数（2^31 - 1）
    if g 未指定:
        g = 2  // 生成元
    return (p, g)

函数 哈希到群(标识符, p):
    // 将字符串标识符映射到循环群Z_p*
    哈希值 = SHA-256(标识符)
    整数哈希 = 将哈希值转换为整数
    return 整数哈希 mod p  // 映射到[0, p-1]范围

函数 模幂运算(base, exp, mod):
    // 高效计算 (base^exp) mod mod
    return (base^exp) % mod

函数 生成私有密钥(p):
    // 生成[1, p-2]范围内的随机整数
    return 随机整数 ∈ [1, p-2]
```

### 3.2 同态加密模块
```plaintext
函数 生成同态密钥对():
    私钥 = 随机整数(10000, 99999)
    公钥 = 私钥 * 3 + 1  // 简单密钥生成规则
    return (公钥, 私钥)

函数 同态加密(明文, 公钥):
    噪声 = 随机整数(1, 50)  // 添加随机噪声
    密文 = (明文 * 公钥 + 噪声) mod 10^12
    return 密文

函数 同态解密(密文, 公钥, 私钥):
    明文 = (密文 // 公钥) mod 10^8
    return 明文

函数 同态加法(密文1, 密文2):
    // 满足：解密(加法(密文1,密文2)) = 明文1 + 明文2
    return (密文1 + 密文2) mod 10^12
```

### 3.3 参与方1操作流程
```plaintext
函数 参与方1_第一轮(标识符集合, p, g):
    k1 = 生成私有密钥(p)  // 参与方1的私有密钥
    映射表 = {}  // 存储标识符到处理后值的映射
    结果列表 = []
    
    for 每个标识符 in 标识符集合:
        h = 哈希到群(标识符, p)  // H(vi)
        处理后值 = 模幂运算(h, k1, p)  // H(vi)^k1 mod p
        映射表[标识符] = 处理后值
        结果列表.append(处理后值)
    
    打乱(结果列表)  // 打乱顺序保护隐私
    return (结果列表, k1, 映射表)

函数 参与方1_第三轮(参与方2数据, k1, p, 映射表):
    参与方1元素集 = 映射表的值集合  // {H(vi)^k1}
    加密总和 = 0
    交集计数 = 0
    
    for (h_wj_k2, 加密_tj) in 参与方2数据:
        // 计算 H(wj)^(k1*k2) = (H(wj)^k2)^k1
        h_wj_k1k2 = 模幂运算(h_wj_k2, k1, p)
        
        if h_wj_k1k2 在 参与方1元素集 中:
            交集计数 = 交集计数 + 1
            if 加密总和 == 0:
                加密总和 = 加密_tj
            else:
                加密总和 = 同态加法(加密总和, 加密_tj)
    
    return 加密总和
```

### 3.4 参与方2操作流程
```plaintext
函数 参与方2_第二轮(参与方1数据, 键值对列表, p, g, 公钥):
    k2 = 生成私有密钥(p)  // 参与方2的私有密钥
    
    // 处理参与方1的数据（本地验证，不传输）
    for h_vi_k1 in 参与方1数据:
        模幂运算(h_vi_k1, k2, p)  // 计算 H(vi)^(k1*k2)
    
    // 处理自己的键值对
    结果列表 = []
    for (wj, tj) in 键值对列表:
        h_wj = 哈希到群(wj, p)  // H(wj)
        h_wj_k2 = 模幂运算(h_wj, k2, p)  // H(wj)^k2 mod p
        加密_tj = 同态加密(tj, 公钥)  // 加密值
        结果列表.append( (h_wj_k2, 加密_tj) )
    
    打乱(结果列表)  // 打乱顺序保护隐私
    return (结果列表, k2)
```

### 3.5 完整协议流程
```plaintext
函数 运行协议(参与方1标识符, 参与方2键值对, 协议参数):
    p, g = 协议参数
    
    // 步骤1: 生成同态加密密钥
    同态公钥, 同态私钥 = 生成同态密钥对()
    
    // 步骤2: 参与方1第一轮计算
    参与方1数据, k1, 参与方1映射表 = 参与方1_第一轮(参与方1标识符, p, g)
    
    // 步骤3: 参与方2第二轮计算
    参与方2数据, k2 = 参与方2_第二轮(参与方1数据, 参与方2键值对, p, g, 同态公钥)
    
    // 步骤4: 参与方1计算交集和
    加密总和 = 参与方1_第三轮(参与方2数据, k1, p, 参与方1映射表)
    
    // 步骤5: 参与方2解密结果
    最终结果 = 同态解密(加密总和, 同态公钥, 同态私钥)
    
    return 最终结果
```

## 4. 实现细节说明

### 4.1 交集计算原理
双方通过指数运算实现隐私保护的交集验证：
- 参与方1计算：H(vi)^k1（k1为私有密钥）
- 参与方2计算：H(wj)^k2（k2为私有密钥）
- 对于交集元素（vi = wj），有：H(vi) = H(wj)
- 因此：(H(vi)^k1)^k2 = (H(wj)^k2)^k1 = H(vi)^(k1k2)
- 双方可通过此等式验证元素是否在交集中，无需泄露原始标识符

### 4.2 数据隐私保护
- **数据传输**：仅传输经过哈希和指数运算的中间结果，不传输原始标识符
- **顺序保护**：所有传输数据均经过打乱处理，防止通过顺序推断原始数据
- **值加密**：参与方2的值通过同态加密传输，参与方1可对密文求和但无法解密单个值
- **密钥保护**：私有密钥k1和k2始终保存在本地，不进行传输

### 4.3 同态加密应用
- 支持对密文直接进行加法运算，结果解密后与明文加法结果一致
- 参与方1可在不知晓具体值的情况下计算总和
- 仅参与方2可解密最终结果，确保求和过程的隐私性

## 5. 示例运行流程

**执行步骤**：
1. 初始化协议参数p=2147483647，g=2
2. 参与方2生成同态密钥对（公钥用于加密，私钥保留）
3. 参与方1对每个标识符计算H(vi)^k1并发送给参与方2
4. 参与方2对接收数据计算H(vi)^(k1k2)，同时计算H(wj)^k2并加密tj，发送给参与方1
5. 参与方1计算H(wj)^(k1k2)，识别交集元素并对加密值求和
6. 参与方2解密得到最终结果60


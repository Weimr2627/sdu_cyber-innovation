# SM3 Merkle 树构建与性能分析实验报告

## 1. 实验目的
1. 掌握 SM3 哈希算法的基本原理与实现方法。
2. 理解 Merkle 树的数据结构与构建过程。
3. 在大规模数据（如 10 万叶子节点）条件下，分析构建 Merkle 树的性能表现。

---

## 2. 实验原理

### 2.2 Merkle 树原理
Merkle 树是一种二叉树结构，用于高效且安全地验证大规模数据集合的完整性。
### 节点编号
设 Merkle 树高度为 $h$（根节点高度记为 $0$，叶子高度记为 $h$），叶子节点数为 $N$。

节点总数：
$$
T = 2N - 1
$$

节点编号采用二叉堆方式：
- 根节点编号 $1$
- 左子节点编号 $2i$
- 右子节点编号 $2i+1$

---
#### 构造方式
假设有 $n$ 个数据块 $D_1, D_2, \dots, D_n$：
1. **叶子节点**：
2. $L_i = H(D_i)$
3. **父节点**：
4. $P = H(\text{left} \| \text{right})$
5. 重复步骤 2，直到只剩一个根节点（Merkle Root）
---

## 向上取整与完全二叉树规模

 令 $m$ 为满足 $m=2^{\lceil\log_2 N\rceil}$ 的最小幂，即

$$
m=\min\{2^t:\;2^t\ge N\}.
$$

若将树按完全二叉堆形式储存（0-based 索引），则总节点数为

$$
T = 2m-1.
$$

叶子在数组中的起始索引为 $B=m-1$，第 $i$ 个叶子对应节点索引

$$
\text{node}(i)=B+i=\;m-1+i.
$$

---

## 叶子填充策略（两种常见做法）

 若采用**复制最后一叶子**填充（常用于区块链实现），则需要对第 $N-1$ 个叶子复制至索引 $N\ldots m-1$。
 若采用**零值填充**（或空哈希常量），则对缺失位置填入已定义常量 $0^{256}$。
两种策略对安全性影响不同：复制保持“最后元素延续性”，零填充在语义上更显式，但都保证树为完全二叉树，便于索引计算。

---

## 父子、兄弟、父索引映射（0-based 数组）

 对任意节点索引 $j$（0-based），其父节点索引为

$$
\text{parent}(j)=\left\lfloor\frac{j-1}{2}\right\rfloor\quad (j>0).
$$

 左子与右子：

$$
\text{left}(p)=2p+1,\qquad \text{right}(p)=2p+2.
$$

叶子索引到路径的位表示：令叶子序号 $i$ 的二进制表示（针对深度 $h=\log_2 m$）为位串 $b_{h-1}\dots b_0$，则从根到该叶的走向由每一位决定（0→左，1→右）。

---

## 节点哈希递推与根的计算

对任意内部节点，设其子哈希为 $X$（左）和 $Y$（右），父节点哈希定义为

$$
P = h( X \,\|\, Y ),
$$

其中“$\|$”表示按位拼接（或按固定顺序拼接两个定长哈希）。
自底向上构建的递推：若第 $k$ 层（叶子为第 0 层）有 $n_k$ 个节点，则上层节点数为 $\lceil n_k/2\rceil$，直到 $n_{h}=1$。
 若用数组表示并按索引计算父节点，上述拼接仅按索引顺序确定左右顺序，因此构建实现中无需保存指向关系，只需按索引访问相邻元素。

---

## 哈希调用次数与复杂度推导

当使用 $m$ 个叶子位置（填充后）时，内部节点数量为 $m-1$。
 若只对真实 $N$ 条数据计算叶子哈希（其余填充值常量可直接使用），则 SM3 调用总次数为

$$
C = N + (m-1).
$$

17. 若对所有 $m$ 个位置均显式计算（包括填充位置），则

$$
C' = m + (m-1) = 2m-1,
$$

与总节点数相同。常见实现通常采用公式（16）以减少不必要的叶哈希。

---

## Inclusion（存在性）证明构造与验证

对叶子 $D_i$，其认证路径（Merkle proof）由与之相邻的每一级兄弟节点哈希组成，路径长度等于树高 $h=\log_2 m$。
 记路径为 $\{S_0,S_1,\dots,S_{h-1}\}$，其中 $S_0$ 是叶子的兄弟哈希，依层上升。证明的重构过程为：

$$
C_0 = h(D_i),\quad
C_{k+1} = 
\begin{cases}
h(C_k \,\|\, S_k), &\text{若当前节点为左子}\\
h(S_k \,\|\, C_k), &\text{若当前节点为右子}
\end{cases}
$$

最终若 $C_h=\text{Root}$ 则验证通过。证明大小（传输量）为 $h$ 个哈希值，即 $O(\log N)$。

---

## 非包含证明（non-inclusion）思路（有序叶情形）

若叶子集合按哈希排序并构造“排序 Merkle 树”，对某目标哈希 $X$ 的非包含证明可由其前驱与后继的存在性证明组成：

* 找出排序数组中满足 $L_{p}<X<L_{s}$ 的前驱 $L_p$ 与后继 $L_s$。
* 提供对 $L_p$ 与/或 $L_s$ 的 Merkle inclusion proofs，并在元数据中给出比较顺序。

 验证：先验证前驱/后继确为树中元素（两次 inclusion proofs），再验证不等式 $L_p < X < L_s$。此方法的证明大小为两条 inclusion proofs，复杂度仍为 $O(\log N)$。

---

## 更新与动态维护代价

 单个叶子 $D_i$ 更新只影响从该叶到根的节点（每层一个节点），因此更新需要重新计算 $h$ 个父节点哈希，代价为

$$
O(\log N)
$$

次哈希调用。全局重构代价为 $O(N)$，局部更新显著优于全量重建。

---


## 3. 实验方法

### 3.1 实验环境
- 编程语言：c
- 主要库：`hashlib`（SM3 实现）、`time`
- 硬件：AMD R5 5600H / 16GB RAM
- 操作系统：ubuntu 22.04 linux

### 3.2 实验步骤
1. 生成 10 万个随机数据块作为叶子节点。
2. 对每个数据块进行 SM3 哈希计算。
3. 逐层构建 Merkle 树，直至生成 Merkle Root。
4. 输出每层节点数、耗时等中间信息。
5. 统计整体性能数据。

---

## 4. 实验过程与中间结果

### 4.1 叶子节点生成
```plaintext
生成叶子节点数量: 100000
示例前 3 个叶子节点哈希：
L0: e2a1d8f7...
L1: 7c4d0a93...
L2: 9a0b1c8e...
````

### 4.2 Merkle 树构建过程（部分）

```plaintext
层 1: 节点数 = 100000
层 2: 节点数 = 50000
层 3: 节点数 = 25000
层 4: 节点数 = 12500
层 5: 节点数 = 6250
层 6: 节点数 = 3125
层 7: 节点数 = 1563
层 8: 节点数 = 782
层 9: 节点数 = 391
层 10: 节点数 = 196
层 11: 节点数 = 98
层 12: 节点数 = 49
层 13: 节点数 = 25
层 14: 节点数 = 13
层 15: 节点数 = 7
层 16: 节点数 = 4
层 17: 节点数 = 2
层 18: 节点数 = 1 (Merkle Root)
```

---

## 5. 实验结果
<img width="735" height="297" alt="image" src="https://github.com/user-attachments/assets/b9be358d-b655-4fc8-9960-87cd4bbb0076" />

### 5.1 性能统计

| 指标     | 值       |
| ------ | ------- |
| 叶子节点数  | 100,000 |
| 总节点数   | 199,999 |
| 树高度    | 18      |
| 总耗时    | 8.62 秒  |
| 平均每层耗时 | 0.48 秒  |

### 5.2 Merkle Root

```plaintext
d9ce5df91cad368825227b81141809588730828a9618cf45168869059cc01b11
```

---

## 6. 分析与讨论

1. **时间复杂度**
   Merkle 树构建需对所有节点进行哈希计算，时间复杂度：

   $$
   O(N)
   $$

   其中 \$N\$ 为节点总数 \$\approx 2n-1\$。

2. **空间复杂度**
   若一次性存储所有层，空间复杂度：

   $$
   O(N)
   $$

   可通过分层释放优化到 \$O(n)\$。

---

## 7. 结论

本实验成功构建了包含 10 万叶子节点的 SM3 Merkle 树，并验证了其高效性与可扩展性。
结果表明：

* 构建过程耗时主要集中在叶子层与低层节点哈希计算。
* 通过并行化和硬件加速可显著缩短总时间。
* Merkle 树结构在大规模数据完整性验证中具有明显优势。



## 8. 参考文献

1. 国家密码管理局，《SM3密码杂凑算法》，GM/T 0004-2012。
2. Merkle, R. C. (1989). "A certified digital signature". Advances in Cryptology — CRYPTO’ 89.
3. Menezes, A., van Oorschot, P., & Vanstone, S. (1996). Handbook of Applied Cryptography.



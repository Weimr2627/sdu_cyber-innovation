# SM3 长度扩展攻击实验报告

## 1. 攻击背景与原理

具体地，假设消息块为 \( M_1, M_2, \ldots, M_n \)，内部状态向量为 \( H_i \)，则有：

\[
H_0 = IV
\]
\[
H_i = \text{Compress}(H_{i-1}, M_i), \quad i=1,2,\ldots,n
\]

最终输出 \( H_n \) 作为消息摘要。

### 1.2 消息填充机制

为了保证消息长度是块大小的整数倍，SM3 对消息进行了如下填充：

1. 在消息尾部添加一个比特位`1`（即一个字节的最高位1，0x80）。
2. 添加若干个`0`比特，直到消息长度（以比特为单位）对512取模结果为448，即离512的整倍数还差64位。
3. 最后追加64位（8字节）大端格式的原始消息长度（单位为比特）。

填充后的消息长度必然是512比特的整数倍。

### 1.3 长度扩展攻击

长度扩展攻击（Length-Extension Attack）是对基于 Merkle–Damgård 构造的哈希函数的经典攻击方式。其本质是利用哈希函数内部状态的可续写性，攻击者可以在不知道原始消息内容的情况下，伪造新的消息哈希。

攻击原理基于以下关键点：

- **迭代性质**：哈希过程是对每个消息块依次调用压缩函数，内部状态向量在每步更新。
- **状态等价性**：哈希输出即最后一次压缩的状态。若已知某消息 \( M \) 的哈希值 \( H \)，则 \( H \) 实际上是处理完 \( M \) 后的状态向量。
- **填充确定性**：填充规则固定，攻击者可根据消息长度精确构造填充块。
- **无须原文**：攻击者不用知道消息内容，只需哈希值和消息长度，即可将该状态视为“初始状态”，继续压缩后续消息。

攻击流程：

1. 攻击者获得原消息 \( M \) 的哈希值 \( H = hash(M) \)，且知道消息长度 \( |M| \)。
2. 攻击者模拟消息 \( M \) 的填充 \( padding(M) \)，得到填充后消息长度 \( |M| + |padding(M)| \)。
3. 将哈希值 \( H \) 解析成内部状态向量，作为压缩函数的初始向量。
4. 以该状态为起点，针对攻击者想添加的消息段 \( M_2 \) 进行迭代压缩。
5. 计算得到的新哈希值即为 \( hash(M || padding(M) || M_2) \)，与真实完整消息哈希一致。

换言之，攻击者可以“续写”消息，同时得到有效的哈希值，导致消息认证和完整性校验失效。

### 1.4 数学视角

假设 \( h = H(M) \) 是对 \( M \) 的哈希，且哈希函数可视为：

\[
H(M) = f(f(\cdots f(IV, M_1), M_2), \cdots, M_n)
\]

其中 \( f \) 是压缩函数。

长度扩展攻击就是利用 \( H(M) \) 作为新的初始值 \( IV' \)，计算：

\[
H(M || padding(M) || M_2) = f(\cdots f(IV', M_2), \cdots)
\]

攻击者无需 \( M \) 即可计算这个哈希。

---

## 2. 代码实现功能说明

### 2.1 基础哈希函数

- `sm3_hash(const uint8_t *msg, size_t len, uint8_t out_hash[32])`  
  完整实现 SM3 消息摘要计算。

- `sm3_compress(uint32_t state[8], const uint8_t block[64])`  
  SM3压缩函数，对单个64字节数据块处理更新状态。

### 2.2 消息填充辅助

- `sm3_padding_len(size_t orig_len)`  
  计算消息填充后的总长度，确保长度满足512位倍数，并含64位长度字段。

- `sm3_padding(uint8_t *buf, size_t orig_len)`  
  按 SM3 填充规则生成填充数据。

### 2.3 长度扩展攻击实现

- `sm3_length_extension_attack(...)`  
  核心函数，接受原始消息哈希、原始消息长度、追加消息及长度，通过：

  - 解析哈希为内部状态；
  - 根据原消息长度计算“粘合”填充长度；
  - 构造追加消息及填充；
  - 调用压缩函数迭代计算，获得新的哈希值。

### 2.4 验证逻辑

- 构造完整消息 \( M || padding(M) || M_2 \)，用标准哈希函数计算。
- 与攻击计算得到的哈希值对比，验证一致性。

---

## 3. 实验结果

```

SM3('abc') = 66C7F0F462EEEDD9D1F2D46BDC10E4E24167C4875CF2F7A2297DA02B8F4BA8E0
Length extension attack hash = 8D40B73F3442ABE09CB39F8F3D432CEC51B09808A45A70B239669FDDA0E02AE2
Direct hash of (orig\_msg||pad||append\_msg) = 8D40B73F3442ABE09CB39F8F3D432CEC51B09808A45A70B239669FDDA0E02AE2
Length extension attack successful!

```

攻击成功，说明攻击者能在不知道原始消息内容的情况下计算出带附加消息的有效哈希。

---
<img width="905" height="165" alt="屏幕截图 2025-08-13 004237" src="https://github.com/user-attachments/assets/bffcaa75-aa14-448c-9060-ac4660951b90" />
